<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Op√©ration S.L.E.D // Terminal</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;600&family=VT323&display=swap" rel="stylesheet">
    <link rel="icon" href="icon.ico" type="image/x-icon">
</head>
<body>

<div class="scanlines"></div>

<div class="terminal-container">
    <header>
        <div class="top-bar">
            <span>CONN: SECURE (NORTH_POLE_VPN)</span>
            <span>MEM: 64KB OK</span>
        </div>
        <h1>
            <span class="prefix">>>></span> PROJECT <span class="highlight">S.L.E.D</span>
        </h1>
        <p class="subtitle">System for Logistics and Efficient Delivery</p>
    </header>

    <nav class="tabs">
        <button class="tab-btn active" data-target="briefing">0. BRIEFING</button>
        <button class="tab-btn" data-target="mission1">1. ANCIEN MOTEUR</button>
        <button class="tab-btn" data-target="mission2">2. NOUVEAU MOTEUR</button>
        <button class="tab-btn" data-target="mission3">3. BIG DATA</button>
        <button class="tab-btn" data-target="mission4">4. OPTIMISATION</button>
        <button class="tab-btn highlight" data-target="mission5">5. [AVANC√â]</button>
        <button class="tab-btn" data-target="annex">6. ARCHIVES</button>
    </nav>

    <main>
        <section id="briefing" class="panel active">
            <div class="typewriter">
                <p>> Connexion au tra√Æneau [S.L.E.D. v4.0]...</p>
                <p>> Analyse des syst√®mes critiques...</p>
                <p class="error">> ERREUR: Latence CPU trop √©lev√©e.</p>
            </div>
            
            <div class="message-box">
                <h3>‚ö†Ô∏è D√âFAILLANCE DU TABLEAU DE BORD</h3>
                <p>Petits lutins, la situation est grave. Avec l'explosion d√©mographique r√©cente, le <strong>Tableau de Bord de Navigation</strong> du vieux tra√Æneau n'arrive plus √† suivre. Quand le P√®re No√´l demande "Est-ce que cet enfant est sage ?", le syst√®me met plusieurs secondes √† r√©pondre.</p>
                
                <p>Actuellement, le logiciel utilise une vieille version impl√©mentant une <span class="tooltip" data-desc="Structure de donn√©es lin√©aire o√π chaque √©l√©ment pointe vers le suivant. Pour trouver un √©l√©ment, il faut parcourir toute la liste en O(N).">liste cha√Æn√©e</span> pour stocker les profils. Avec <strong>2 milliards d'enfants</strong>, le temps de r√©ponse emp√™che le P√®re No√´l de r√©pondre √† la demande de chaque enfant.</p>
                
                <p><strong>VOTRE MISSION :</strong> Vous devez r√©√©crire le noyau du tableau de bord. Nous devons passer d'une recherche lin√©aire lente √† une <span class="tooltip" data-desc="Structure de donn√©es (Hash Table) permettant un acc√®s quasi-constant (O(1)) aux donn√©es via une cl√© unique.">Table de Hachage</span> performante avant la tourn√©e du 24 d√©cembre.</p>
            </div>
        </section>

        <section id="mission1" class="panel">
            <h2>/// PHASE 1 : ANCIEN MOTEUR (LISTES CHA√éN√âES)</h2>
            <p>Avant de construire un syst√®me plus rapide, nous devons impl√©menter et analyser le syst√®me actuel pour comprendre ses limites. L'objectif est de coder la gestion des donn√©es via une <strong>Liste Cha√Æn√©e</strong> simple.</p>
            
            <div class="info-terminal">
                > INFO: Dans cette version, nous consid√©rons qu'il n'y a PAS d'homonymes. Chaque enfant poss√®de un Nom de famille unique qui servira d'identifiant unique. Cependant dans la r√©alit√©, il y a des homonymes, afin de traiter ce cas, plusieurs solutions sont possibles :
                <ul>
                    <li>Utiliser une liste cha√Æn√©e pour stocker les enfants avec le m√™me nom de famille.</li>
                    <li>Refuser l'ajout d'un enfant avec un nom de famille d√©j√† existant.</li>
                    <li>Utiliser une cl√© plus complexe (ex: Nom de famille + Pr√©nom).</li>
                    <li>Remplacer l'enfant d√©j√† pr√©sent dans la table par le nouvel enfant.</li>
                </ul>
            </div>

            <div class="task-list">
                <p>[OBJECTIF 1.1] Structures de donn√©es (fichier <code>santa.h</code>) :</p>
            </div>

            <div class="code-editor">
                <div class="editor-header">santa.h</div>
<pre><code>typedef struct {
    char * surname;       <span class="comment">/* Ex: "Blanc" */</span>
    char * firstname;     <span class="comment">/* Ex: "L√©o" */</span>
    unsigned int age;     <span class="comment">/* Age en ann√©es */</span>
    char * address;       <span class="comment">/* Adresse postale */</span>
    int is_wise;          <span class="comment">/* 1 = Sage */</span>
} <span class="tooltip" data-desc="Structure repr√©sentant un dossier enfant complet.">Child</span>;

typedef struct HCell {
    Child * element;      <span class="comment">/* Pointeur vers le dossier enfant */</span>
    struct HCell * next;  <span class="comment">/* Pointeur vers l'√©l√©ment suivant */</span>
} <span class="tooltip" data-desc="Maillon de la liste cha√Æn√©e.">HCell</span>;
</code></pre>
            </div>

            <div class="task-list">
                <p>[OBJECTIF 1.2] Gestion basique d'un enfant :</p>
                <p>Dans un fichier <code>child.c</code>, impl√©mentez les fonctions suivantes :</p>
                <ul>
                    <li><code>Child* createChild()</code> : Demande √† l'utilisateur de saisir les infos. Vous devez allouer la m√©moire pour <code>surname, firstname et address</code>.</li>
                    <li><code>void displayChild(Child *e)</code> : Affiche la fiche d'un enfant (ex: "[SAGE] Blanc L√©o (12 ans) - 123 Rue de la Paix, 75000 Paris").</li>
                </ul>
                <p>üëâ <em>Testez ces fonctions avec un fichier <code>mainChild.c</code> qui cr√©e un enfant manuellement et l'affiche.</em></p>
            </div>

            <hr>

            <div class="task-list">
                <p>[OBJECTIF 1.3] Impl√©mentation de la Liste Cha√Æn√©e :</p>
                <p>Dans un fichier <code>linkedList.c</code>, codez les fonctions de gestion de liste :</p>
                <ul>
                    <li><code>HCell* enqueueChild(HCell *h_entry, Child *e)</code> : Ajoute un enfant en queue de liste.
                        <br><span class="highlight">ATTENTION :</span> Dans notre cas, nous consid√©rons qu'il n'y a PAS de conflit de cl√© (homonymes).
                    </li>
                    <li><code>HCell* removeChildList(HCell *h_entry, char *key)</code> : Supprime un enfant de la liste.</li>
                    <li><code>void printList(HCell *h_entry)</code> : <span class="tooltip" data-desc="utilisez displayChild">Affiche</span> toute la liste.</li>
                    <li><code>int listSize(HCell *h_entry)</code> : Retourne le nombre d'√©l√©ments dans la liste.</li>
                    <li><code>Child* getChildList(HCell *h_entry, char *key)</code> : Recherche un enfant par son nom (key).
                        <br><em>Conseil : Pour manipuler les cha√Ænes et le parsing, regardez les fonctions <code>strtok</code> (voir exemple sur la page Universitice) et <code>strdup</code>.</em>
                    </li>
                    <li><code>HCell* loadFileList(const char *filename)</code> : Lit un fichier et retourne la liste cha√Æn√©e compl√®te.</li>
                </ul>
            </div>

            <div class="message-box">
                <h3>üß™ TEST (mainList.c)</h3>
                <p>Cr√©ez un ex√©cutable qui prend le nom d'un fichier en argument. Pour cela, vous pouvez t√©l√©charger le fichier <code>dataset_flipou.txt</code> contenant la liste de 20 enfants de la ville de <a href="https://maps.app.goo.gl/uyHRCpmkavFz8nT89" class="link">Flipou</a>.</p>
                <div class="download-zone">
                    <a href="dataset_flipou.txt" class="retro-btn">‚¨áÔ∏è DOWNLOAD DATASET_FLIPOU.TXT</a>
                </div>
                <ol>
                    <li>Charge le fichier dans une liste.</li>
                    <li>Affiche la liste compl√®te et sa taille (V√©rifiez que cela correspond au fichier source !).</li>
                    <li>Demande √† l'utilisateur un nom √† rechercher et affiche le r√©sultat (Trouv√©/Non trouv√©).</li>
                    <li>Demande √† l'utilisateur un nom √† supprimer, effectue la suppression et affiche la nouvelle liste.</li>
                </ol>
            </div>
        </section>

        <section id="mission2" class="panel">
            <h2>/// PHASE 2 : NOUVEAU MOTEUR (TABLE DE HACHAGE)</h2>
            <p>La recherche lin√©aire dans une liste est trop lente, en O(N). Nous devons maintenant passer √† une architecture bas√©e sur une <strong>Table de Hachage</strong>.</p>
            <p>Le principe : Utiliser une fonction math√©matique pour trouver l'index directement. Les collisions (plusieurs enfants au m√™me index) seront g√©r√©es par les listes cha√Æn√©es que vous venez de coder.</p>

            <div class="task-list">
                <p>[OBJECTIF 2.1] Structure du Moteur (ajout √† <code>santa.h</code>) :</p>
            </div>

            <div class="code-editor">
<pre><code>typedef struct {
    HCell ** table;       <span class="comment">/* Tableau de pointeurs (Les entr√©es de la table de hachage) */</span>
    unsigned int size;    <span class="comment">/* Nombre d'entr√©es disponibles (taille du tableau) */</span>
} <span class="tooltip" data-desc="La table de hachage principale repr√©sentant le disque dur du tra√Æneau.">HTable</span>;</code></pre>
            </div>

            <div class="task-list">
                <p>[OBJECTIF 2.2] Impl√©mentation (fichier <code>hashTable.c</code>) :</p>
                <p>Vous pouvez et DEVEZ r√©utiliser les fonctions de vos listes cha√Æn√©es (<code>enqueueChild</code>, <code>printList</code>, etc.) pour g√©rer le contenu de chaque case du tableau.</p>
                <ul>
                    <li><code>int hash1(HTable *ht, char *clef)</code> : Fonction de hachage. Vous pouvez utiliser la fonction suivante :
                        <div class="code-editor">
                            <div class="editor-header">Algo Indexation na√Øf</div>
<pre><code><span class="comment">// Calcule l'index bas√© sur la longueur du nom</span>
int hash_index = strlen(key) % size;</code></pre>
            </div>
                    </li>
                    <li><code>void addChild(HTable* htable, Child *e)</code> : Calcule le hash, puis utilise <code>enqueueChild</code> pour ajouter l'enfant √† l'index correct.</li>
                    <li><code>HTable* loadFileHash(const char *filename)</code> : Charge un fichier complet dans la table (R√©utilisez la logique de lecture de fichier de la phase 1).</li>
                    <li><code>Child* getChildHTable(HTable *h, char *key)</code> : Trouve l'index via le hash, puis cherche dans la liste correspondante (R√©utilisez <code>getChildList</code>).</li>
                    <li><code>void removeChildHash(HTable *h, char *key)</code> : Supprime un enfant de la table.</li>
                </ul>
            </div>

            <div class="task-list">
                <p>[OBJECTIF 2.3] Affichage Diagnostic :</p>
                <p>Impl√©mentez <code>void displayTable(HTable* htable)</code>. Vous pouvez pour cela vous inspirer de l'affichage suivant :
            </div>

            <div class="code-editor">
                <div class="editor-header">Exemple d'affichage</div>
<pre><code>
OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
O Affichage de la table de Hachage O
OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO

Elements √† l'indice 0
------------------------
[SAGE] Blanc L√©o (12 ans) - 123 Rue de la Paix, 75000 Paris
[SAGE] Lelon Belin (14 ans) - 15 Avenue Regent, 76000 Rouen

Elements √† l'indice 1
------------------------
[PAS SAGE] Leverd Amoro (16 ans) - 502 Place High, 10485 Hamburg
                             ...
</code></pre>
            </div>

            <div class="message-box">
                <h3>üöÄ LANCEMENT (mainHash.c)</h3>
                <p>Comme pour la phase pr√©c√©dente, cr√©ez un main qui :</p>
                <ol>
                    <li>Prend un nom de fichier en argument.</li>
                    <li>Initialise la table (taille 10 pour commencer).</li>
                    <li>Affiche la table avec la fonction ci-dessus.</li>
                    <li>Permet √† l'utilisateur de tester la recherche et la suppression interactivement.</li>
                </ol>
            </div>
        </section>

        <section id="mission3" class="panel">
            <h2>/// PHASE 3 : IMPORTATION DE DONN√âES MASSIVES</h2>
            <p>Maintenant que le syst√®me tient la route avec quelques donn√©es manuelles, passons aux choses s√©rieuses et importons des donn√©es d'enfants provenant de la terre enti√®re.
            
            <div class="download-zone">
                <a href="dataset_world.txt" class="retro-btn">‚¨áÔ∏è DOWNLOAD DATASET_WORLD.TXT</a>
            </div>
            </br>

            <div class="message-box">
                <h3>üìä AFFICHAGE STATISTIQUES</h3>
                <p>A mesure que le nombre d'enfants augmente, il devient de plus en plus difficile de maintenir un affichage complet de la table de hachage. Modifiez votre affichage pour montrer uniquement les statistiques de r√©partition.</p>
            </div>

            <div class="task-list">
                <p>[OBJECTIF 3.1] Analyse de Performance :</p>
                <ul>
                    <li>Cr√©ez une fonction <code>displayStats(HTable *table)</code> qui affiche :
                        <ul>
                            <li>Nombre total d'enfants.</li>
                            <li>Nombre d'entr√©es de la table de hachage vides.</li>
                            <li>La taille de la liste la plus longue (pire cas de collision).</li>
                            <li>Le nombre de <span class="tooltip" data-desc="Nombre d'enfants avec le m√™me hash (cl√©).">collisions</span>. Par exemple, si 10 enfants dans une table de taille 10 ont le m√™me hash, le taux de collisions est de 100%. Cependant, si chaque enfant a un hash diff√©rent, le taux de collisions est de 0%.</li>
                            <li>La qualit√© de la r√©partition. Pour cela, vous pouvez utiliser la formule suivante :
                                <div class="code-editor">
                                <pre><code>// &alpha; = nombre d'enfants / taille de la table
qualit√© = somme((nombre_d'enfants_par_entr√©e - &alpha;) / &alpha;)</code></pre>
                                </div>
                                Plus la qualit√© est proche de 0, plus la r√©partition est uniforme.
                            </li>

                        </ul>
                        <!-- Exemple de sortie : -->
                        <div class="code-editor limit-height">
                            <div class="editor-header">Exemple de sortie</div>
                            <pre><code>./mainDisplayStats dataset_flipou.txt 10
===================================================================================
1. Prend un nom de fichier et une taille de table en arguments.
===================================================================================
Fichier charg√© : dataset_flipou.txt
===================================================================================
2. Initialise la table.
===================================================================================
Taille de la table : 10
20 donn√©es √† lire (100%)
===================================================================================
3. Affiche les statistiques.
===================================================================================
Nombre total d'enfants : 20
Nombre d'entr√©es de la table de hachage vides : 0
Taille de la liste la plus longue : 4
Nombre de collisions : 16
Qualit√© de la r√©partition : 4.000
===================================================================================
4. Affiche le nombre d'enfants par entr√©e.
===================================================================================
(0)1 - (1)1 - (2)2 - (3)2 - (4)1 - (5)2 - (6)3 - (7)1 - (8)4 - (9)3


./mainDisplayStats dataset_world.txt 30
===================================================================================
1. Prend un nom de fichier et une taille de table en arguments.
===================================================================================
Fichier charg√© : dataset_world.txt
===================================================================================
2. Initialise la table.
===================================================================================
Taille de la table : 30
100000 donn√©es √† lire (100%)
===================================================================================
3. Affiche les statistiques.
===================================================================================
Nombre total d'enfants : 100000
Nombre d'entr√©es de la table de hachage vides : 0
Taille de la liste la plus longue : 16515
Nombre de collisions : 100000
Qualit√© de la r√©partition : 32.569
===================================================================================
4. Affiche le nombre d'enfants par entr√©e.
===================================================================================
(0)27 - (1)18 - (2)37 - (3)283 - (4)1886 - (5)6797 - (6)13292 - (7)16515 
- (8)15200 - (9)11669 - (10)7962 - (11)5379 - (12)3907 - (13)3561 - 
(14)3174 - (15)2762 - (16)2210 - (17)1594 - (18)1120 - (19)702 - (20)513 
- (21)321 - (22)270 - (23)225 - (24)163 - (25)141 - (26)102 - (27)81 - 
(28)52 - (29)37</code></pre>
                        </div>
                    </li>
                    <li>Cr√©ez une fonction <code>void displayTableSize(HTable *table)</code> pour afficher le nombre d'enfants par entr√©e de la table de hachage.
                    <div class="info-terminal">
                        > EXEMPLE : (0)1001 - (1)990 - (2)1013 - (3)932 - (4)1029 ...
                    </div>
                    </li>
                </ul>

                <div class="info-terminal">
                    > INFO: Avec votre table de hachage de taille 10 le nombre de collisions risque d'augmenter <span class="highlight">consid√©rablement</span>. Augmentez la taille de la table afin de pouvoir traiter la liste mondiale de mani√®re plus efficace. Analysez le nombre de collisions pour diff√©rentes tailles de table. Augmentez de plus en plus la taille de la table am√©liore-t-il le nombre de collisions ?
                </div>
            </div>
        </section>

        <section id="mission4" class="panel">
            <h2>/// PHASE 4 : OPTIMISATION DU MOTEUR</h2>
            <p>L'analyse des statistiques r√©v√®le des <span class="highlight">embouteillages critiques</span>. La fonction de hachage na√Øve (bas√©e sur la longueur) stocke tous les noms de 5 lettres au m√™me endroit !</p>

            <div class="info-terminal">
                > ALERT: Collision Rate > 85%. Surcharge CPU imminente.
            </div>

            <p>Nous devons disperser les donn√©es de mani√®re plus uniforme pour essayer d'atteindre la complexit√© <span class="tooltip" data-desc="Notation math√©matique pour la complexit√© temporelle d'un algorithme. O(1) signifie que le temps d'ex√©cution est constant, ind√©pendant de la taille de l'entr√©e.">O(1)</span>.</p>

            <div class="task-list">
                <p>[OBJECTIF 4.1] Hachage ASCII v1 (First Char) :</p>
                <ul>
                    <li>Impl√©mentez <code>unsigned int hashASCIIFirst(char *key, int size)</code>.</li>
                    <li>Cette fonction utilise uniquement le code ASCII du <strong>premier caract√®re</strong> de la cl√©.</li>
                    <li><em>Question :</em> Pourquoi cela pose-t-il encore probl√®me ?</li>
                </ul>
            </div>

            <div class="task-list">
                <p>[OBJECTIF 4.2] Hachage ASCII v2 (Sum) :</p>
                <ul>
                    <li>Impl√©mentez <code>unsigned int hashASCIISum(char *key, int size)</code>.</li>
                    <li>Cette fonction calcule la <strong>somme des codes ASCII</strong> de tous les caract√®res de la cl√©, modulo la taille de la table.</li>
                    <li>Analysez les nouvelles statistiques via <code>displayStats</code>. La r√©partition est-elle meilleure ?</li>
                </ul>
            </div>
        </section>

        <section id="mission5" class="panel">
            <h2>/// PHASE 5 : FUTUR IMM√âDIAT</h2>
            
            <p>Pour les petits lutins motiv√©s, nous devons pr√©parer le tra√Æneau pour les d√©cennies √† venir.</p>

            <div class="task-list">
                <p>[OBJECTIF 5.1] Hachage de meilleur Qualit√© (DJB2) :</p>
                <ul>
                    <li>La m√©thode "Somme ASCII" est encore trop pr√©visible (les anagrammes comme "RAME" et "MARE" ont le m√™me hash !).</li>
                    <li>Impl√©mentez l'algorithme <strong>DJB2</strong>. Voir la section <strong>ARCHIVES</strong> pour la documentation technique.</li>
                </ul>
            </div>

            <div class="message-box" style="border-color: #ffee00; background: rgba(255, 238, 0, 0.05);">
                <h3>üöÄ D√âFI FINAL : COLONISATION SPATIALE</h3>
                <p><strong>SIMULATION TEMPORELLE : ANN√âE 2050.</strong></p>
                <p>La population humaine s'est √©tendue sur Mars. Nous ne g√©rons plus 2 milliards, mais 20 milliards d'enfants.</p>
                <p>Probl√®me : Notre table de taille fixe sature (Facteur de charge > 10). Les collisions explosent.</p>
            </div>

            <div class="task-list">
                <p>[OBJECTIF 5.2] Redimensionnement Dynamique (Rehashing) :</p>
                <ul>
                    <li>Impl√©mentez une fonction de surveillance <code>float loadFactor(HTable *table)</code> (Nombre √©l√©ments / Taille tableau).</li>
                    <li>Si le facteur d√©passe <strong>0.75</strong>, d√©clenchez une proc√©dure d'urgence :
                        <ol>
                            <li>Cr√©er une nouvelle table 2x plus grande.</li>
                            <li>Recalculer le hash de TOUS les enfants existants pour les placer dans la nouvelle table (car <code>modulo size</code> change !).</li>
                            <li>Lib√©rer l'ancienne table.</li>
                        </ol>
                    </li>
                </ul>
            </div>
            
            <div class="code-editor">
                <div class="editor-header">Prototype sugg√©r√©</div>
<pre><code><span class="comment">// Redimensionne la table si n√©cessaire</span>
void verifyAndResize(HTable *table);</code></pre>
            </div>

            <div class="message-box">
                <h3>üöÄ IMPORTATION DE LA LISTE INTERPLAN√âTAIRE</h3>
                <p>Avec la population humaine qui s'√©tend sur d'autres plan√®tes, les donn√©es d'enfants sont maintenant disponibles sur d'autres plan√®tes. Vous pouvez importer la liste des enfants interplan√©taires en utilisant la fonction <code>loadFile</code>.</p>
                <div class="download-zone">
                    <a href="dataset_interplanetary.txt" class="retro-btn">‚¨áÔ∏è DOWNLOAD DATASET_INTERPLANETARY.TXT</a>
                </div>  
            </div>
            
            <p class="subtitle">Bonne chance, petits lutins !</p>
        </section>

        <section id="annex" class="panel">
            <h2>/// CLASSIFIED_DATA_ARCHIVE</h2>
            <p>Acc√®s aux documents historiques du d√©partement R&D.</p>

            <div class="info-terminal">
                > ACCESS GRANTED: Loading historical files...
            </div>

            <h3>DOCUMENT #1 : L'Origine du Hachage</h3>
            <p>L'id√©e du hachage n'est pas nouvelle. Elle a √©t√© formul√©e pour la premi√®re fois au d√©but des ann√©es <strong>1950</strong> par <strong>Hans Peter Luhn</strong> (un ing√©nieur d'IBM).</p>
            <p>Luhn cherchait un moyen d'acc√©l√©rer la recherche de compos√©s chimiques enregistr√©s sous forme cod√©e.</p>

            <hr style="border-color: #333; border-style: dashed;">

            <h3>DOCUMENT #2 : L'Algorithme DJB2</h3>
            <p>L'algorithme que nous utilisons a √©t√© cr√©√© par <strong>Daniel J. Bernstein</strong> (d'o√π le nom "DJB") en 1991.</p>
            
            <p><strong>Pourquoi √ßa marche ?</strong></p>
            <p>Cet algorithme utilise deux "nombres magiques" :</p>
            <ul>
                <li><strong>5381</strong> : La valeur initiale du hash. Ce nombre premier a √©t√© choisi exp√©rimentalement car il produit tr√®s peu de collisions.</li>
                <li><strong>33</strong> : Le multiplicateur. Multiplier par 33 m√©lange tr√®s efficacement les bits du mot binaire.</li>
            </ul>

            <div class="code-editor">
                <div class="editor-header">Impl√©mentation de R√©f√©rence (DJB2)</div>
<pre><code>unsigned long hash(char *str) {
    unsigned long hash = 5381;
    int c;

    while (c = *str++)
        <span class="comment">// L'astuce binaire : (hash << 5) + hash </span>
        <span class="comment">// est une fa√ßon ultra-rapide d'√©crire "hash * 33"</span>
        hash = ((hash << 5) + hash) + c; 

    return hash;
}</code></pre>
            </div>
            <p><em>Note : Le d√©calage de bits <code>&lt;&lt; 5</code> revient √† multiplier par 32. En ajoutant <code>+ hash</code>, on obtient une multiplication par 33, mais beaucoup plus rapide pour le processeur !</em></p>
        </section>
    </main>

    <footer>
        <p>TERMINAL V2.4 | P√îLE NORD IT DEPT | <span id="clock">--:--:--</span></p>
    </footer>
</div>

<div id="retro-tooltip" class="hidden"></div>
<div id="custom-cursor"></div>
<script src="script.js"></script>
</body>

</html>