<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Op√©ration S.L.E.I.D // Terminal</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;600&family=VT323&display=swap" rel="stylesheet">
    <link rel="icon" href="icon.png">
</head>
<body>

<div class="scanlines"></div>

<div class="terminal-container">
    <header>
        <div class="top-bar">
            <span>CONN: SECURE (NORTH_POLE_VPN)</span>
            <span>MEM: 64KB OK</span>
        </div>
        <h1>
            <span class="prefix">>>></span> PROJECT <span class="highlight">S.L.E.I.D</span>
        </h1>
        <p class="subtitle">System for Logistics and Efficient Delivery</p>
    </header>

    <nav class="tabs">
        <button class="tab-btn active" data-target="briefing">0. BRIEFING</button>
        <button class="tab-btn" data-target="mission1">1. ARCHITECTURE</button>
        <button class="tab-btn" data-target="mission2">2. MOTEUR</button>
        <button class="tab-btn" data-target="mission3">3. BIG DATA</button>
        <button class="tab-btn" data-target="mission4">4. OPTIMISATION</button>
        <button class="tab-btn highlight" data-target="mission5">5. [AVANC√â]</button>
        <button class="tab-btn" data-target="annex">6. ARCHIVES</button>
    </nav>

    <main>
        <section id="briefing" class="panel active">
            <div class="typewriter">
                <p>> Connexion au tra√Æneau [S.L.E.I.D. v4.0]...</p>
                <p>> Analyse des syst√®mes critiques...</p>
                <p class="error">> ERREUR: Latence CPU trop √©lev√©e.</p>
            </div>
            
            <div class="message-box">
                <h3>‚ö†Ô∏è D√âFAILLANCE DU TABLEAU DE BORD</h3>
                <p>Petits lutins, la situation est grave. Avec l'explosion d√©mographique r√©cente, le <strong>Tableau de Bord de Navigation</strong> du vieux tra√Æneau n'arrive plus √† suivre. Quand le P√®re No√´l demande "Est-ce que cet enfant est sage ?", le syst√®me met plusieurs secondes √† r√©pondre.</p>
                
                <p>Actuellement, le logiciel utilise une vieille version impl√©mentant une <span class="tooltip" data-desc="Structure de donn√©es lin√©aire o√π chaque √©l√©ment pointe vers le suivant. Pour trouver un √©l√©ment, il faut parcourir toute la liste en O(N).">liste cha√Æn√©e</span> pour stocker les profils. Avec <strong>2 milliards d'enfants</strong>, le temps de r√©ponse emp√™che le P√®re No√´l de r√©pondre √† la demande de chaque enfant.</p>
                
                <p><strong>VOTRE MISSION :</strong> Vous devez r√©√©crire le noyau du tableau de bord. Nous devons passer d'une recherche lin√©aire lente √† une <span class="tooltip" data-desc="Structure de donn√©es (Hash Table) permettant un acc√®s quasi-constant (O(1)) aux donn√©es via une cl√© unique.">Table de Hachage</span> performante avant la tourn√©e de ce soir.</p>
            </div>
        </section>

        <section id="mission1" class="panel">
            <h2>/// PHASE 1 : STRUCTURE DE DONN√âES</h2>
            <p>Afin de pouvoir r√©pondre √† la demande de chaque enfant, le d√©partement <strong>Administratif</strong> a mis √† votre disposition une structure de donn√©es permettant de stocker les profils de chaque enfant.</p>

            <div class="task-list">
                <p>[OBJECTIF 1.1] Cr√©er et compl√©ter le fichier <code>santa_hash.h</code> :</p>
            </div>

            <div class="code-editor">
                <div class="editor-header">santa_hash.h</div>
<pre><code>typedef struct {
    char * surname;       <span class="comment">/* Ex: "Blanc" */</span>
    char * firstname;     <span class="comment">/* Ex: "L√©o" */</span>
    unsigned int age;     <span class="comment">/* Age en ann√©es */</span>
    char * address;       <span class="comment">/* Adresse postale */</span>
    int is_wise;          <span class="comment">/* 1 = Sage */</span>
} <span class="tooltip" data-desc="Structure repr√©sentant un dossier enfant complet.">Child</span>;

typedef struct HCell {
    Child * element;      <span class="comment">/* Pointeur vers le dossier enfant */</span>
    struct HCell * next;  <span class="comment">/* Gestion des collisions (liste cha√Æn√©e) */</span>
} <span class="tooltip" data-desc="Maillon de la cha√Æne pour g√©rer les collisions dans la table.">HCell</span>;

typedef struct {
    HCell ** table;     <span class="comment">/* Tableau de pointeurs (Les "Tiroirs") */</span>
    unsigned int size;    <span class="comment">/* Nombre de tiroirs disponibles */</span>
} <span class="tooltip" data-desc="La table de hachage principale repr√©sentant le disque dur du tra√Æneau.">HTable</span>;</code></pre>
            </div>

            <div class="task-list">
                <p>[OBJECTIF 1.2] Compl√©ter les diff√©rentes fonctions :</p>
                <ul>
                    <li><code>HTable* createTable(unsigned int size)</code> : Alloue la m√©moire du tableau de bord. <span class="highlight">CRITIQUE :</span> Tous les entr√©e de la table de hachage doivent √™tre √† NULL initialement.</li>
                    <li><code>Child* createChild()</code> : Demande √† l'utilisateur de saisir les infos (Nom, Pr√©nom, Age, Adresse, √âtat) et retourne la structure allou√©e.</li>
                    <li><code>void displayChild(Child *e)</code> : Affiche la fiche d'un enfant (ex: "[SAGE] Blanc L√©o (12 ans) - 123 Rue de la Paix, 75000 Paris").</li>
                    <li><code><span class="tooltip" data-desc=" Si la liste en argument est √©gale √† NULL alors la fonction retournera une nouvelle liste constitu√©e de l'unique cellule nouvellement cr√©√©e.">HCell* enqueueChild(HCell *h_entry, Child *e)</span></code> : Ajoute un enfant dans une liste cha√Æn√©e en queue de liste (gestion des collisions).</li>
                    <li><code>void printHEntry(HCell *h_entry) </code><span class="tooltip" data-desc="Pour cela vous pouvez utiliser la fonction displayChild">Affiche</span> la liste d'enfant pr√©sente dans l'entr√©e correspondant.</li>
                </ul>
            </div>
        </section>

        <section id="mission2" class="panel">
            <h2>/// PHASE 2 : MOTEUR D'INDEXATION v1.0</h2>
            <p>Le tableau de bord a besoin d'une "cl√©" pour retrouver un enfant instantan√©ment. Nous allons utiliser le <bold>NOM</bold> de famille comme cl√© de recherche pour l'instant.</p>

            <div class="info-terminal">
                > INFO: La fonction de hachage transforme une cl√© (ex: "Blanc") en un index num√©rique (ex: 12) correspondant √† une entr√©e de la table de hachage de la table de hachage.
            </div>

            <p><strong>2.1 Impl√©mentation Na√Øve</strong></p>
            <p>Pour tester le mat√©riel, commencez par une fonction de hachage basique bas√©e sur la longueur du nom. Une table de hachage de <span class="highlight">taille 10</span> sera suffisante afin de pouvoir tester le mat√©riel.</p>

            <div class="code-editor">
                <div class="editor-header">Algo Indexation na√Øf</div>
<pre><code><span class="comment">// Calcule l'index bas√© sur la longueur du nom</span>
int hash_index = (strlen(key) - 1) % size;</code></pre>
            </div>

            <div class="task-list">
                <p>[OBJECTIF 2.1] Fonctions d'insertion et d'affichage :</p>
                <ul>
                    <li><code>void addChild(HTable* table)</code> : 
                        <ol>
                            <li>Utilise la fonction <code>createChild</code> pour cr√©er un nouvel enfant.</li>
                            <li>Calcule le hash du nom de l'enfant.</li>
                            <li>Ajoute l'enfant dans la liste cha√Æn√©e correspondante (entr√©e de la table de hachage).</li>
                        </ol>
                    </li>
                    <li><code>void displayTable(HTable* table)</code> : Affiche l'√©tat de la m√©moire. Pour chaque index, affichez tous les enfants pr√©sents.</li>
                </ul>
            </div>

            <hr>

            <p><strong>2.2 Module de Recherche</strong></p>
            <p>C'est la fonction que le P√®re No√´l utilisera en plein vol.</p>
            <div class="task-list">
                <ul>
                    <li><code>Child* getChild(HTable table, char *key)</code> : Retourne la fiche de l'enfant ou NULL si introuvable.</li>
                    <li><code>void removeChild(HTable table, char *key)</code> : Supprime un enfant de la base.</li>
                </ul>
            </div>
        </section>

        <section id="mission3" class="panel">
            <h2>/// PHASE 3 : IMPORTATION DES DONN√âES</h2>
            <p>Maintenant que le syst√®me tient la route avec quelques donn√©es manuelles, passons aux choses s√©rieuses et importons quelques donn√©es d'enfants provenant de la ville de <a href="https://maps.app.goo.gl/uyHRCpmkavFz8nT89" class="link">Flipou</a>.</p>
            
            <div class="download-zone">
                <a href="dataset_flipou.txt" class="retro-btn">‚¨áÔ∏è DOWNLOAD DATASET_FLIPOU.TXT</a>
            </div>

            <div class="task-list">
                <p>[OBJECTIF 3.1] Parser le fichier :</p>
                <ul>
                    <li><code>HTable* loadFile(const char *filename)</code> : Lit un fichier <span class="tooltip" data-desc="Format de fichier texte avec sur la premi√®re ligne le nombre d'enfants √† importer et les autres lignes les donn√©es de chaque enfant (format: Nom;Prenom;Age;Adresse;Sage).">TXT</span> et remplit la table.</li>
                </ul>
            </div>

            <div class="message-box">
                <h3>üìä AFFICHAGE STATISTIQUES</h3>
                <p>A mesure que le nombre d'enfants augmente, il devient de plus en plus difficile de maintenir un affichage complet de la table de hachage. Modifiez votre affichage pour montrer uniquement les statistiques de r√©partition.</p>
            </div>

            <div class="task-list">
                <p>[OBJECTIF 3.2] Analyse de Performance :</p>
                <ul>
                    <li>Cr√©ez une fonction <code>displayStats(HTable table)</code> qui affiche :
                        <ul>
                            <li>Nombre total d'enfants.</li>
                            <li>Nombre d'entr√©es de la table de hachage vides.</li>
                            <li>La taille de la liste la plus longue (pire cas de collision).</li>
                            <li>Le nombre de <span class="tooltip" data-desc="Nombre d'entr√©es de la table de hachage qui contiennent plusieurs enfants">collisions</span>.</li>
                        </ul>
                    </li>
                    <li>Modifiez la fonction <code>displayTable</code> pour que, au lieu d'afficher l'ensemble des √©l√©ments, elle affiche le nombre de ces √©l√©ments par entr√©e de la table de hachage.
                    <p>Exemple : (0)1001 - (1)990 - (2)1013 - (3)932 - (4)1029 ...</p>
                    </li>
                </ul>
                <div class="message-box">
                    <h3>üåç IMPORTATION DE LA LISTE MONDIALE</h3>
                    <p>Maintenant que vous avez test√© le mat√©riel avec la liste de Flipou, vous pouvez √©galement importer la liste mondiale en utilisant la fonction <code>loadFile</code> et afficher les statistiques de r√©partition.</p>
                    <div class="download-zone">
                        <a href="dataset_world.txt" class="retro-btn">‚¨áÔ∏è DOWNLOAD DATASET_WORLD.TXT</a>
                    </div>  
                </div>
                <div class="info-terminal">
                    > INFO: Avec votre table de hachage de taille 10 le nombre de collisions risque d'augmenter considerablement. Augmentez la taille de la table afin de pouvoir traiter la liste mondiale de mani√®re plus efficace.
                </div>
            </div>
        </section>

        <section id="mission4" class="panel">
            <h2>/// PHASE 4 : OPTIMISATION DU MOTEUR</h2>
            <p>L'analyse des statistiques r√©v√®le des <span class="highlight">embouteillages critiques</span>. La fonction de hachage na√Øve (bas√©e sur la longueur) stocke tous les noms de 5 lettres au m√™me endroit !</p>

            <div class="info-terminal">
                > ALERT: Collision Rate > 85%. Surcharge CPU imminente.
            </div>

            <p>Nous devons disperser les donn√©es de mani√®re plus uniforme pour essayer d'atteindre la complexit√© <span class="tooltip" data-desc="Notation math√©matique pour la complexit√© temporelle d'un algorithme. O(1) signifie que le temps d'ex√©cution est constant, ind√©pendant de la taille de l'entr√©e.">O(1)</span>.</p>

            <div class="task-list">
                <p>[OBJECTIF 4.1] Hachage ASCII v1 (First Char) :</p>
                <ul>
                    <li>Impl√©mentez <code>unsigned int hashASCIIFirst(char *key, int size)</code>.</li>
                    <li>Cette fonction utilise uniquement le code ASCII du <strong>premier caract√®re</strong> de la cl√©.</li>
                    <li><em>Question :</em> Pourquoi cela pose-t-il encore probl√®me ?</li>
                </ul>
            </div>

            <div class="task-list">
                <p>[OBJECTIF 4.2] Hachage ASCII v2 (Sum) :</p>
                <ul>
                    <li>Impl√©mentez <code>unsigned int hashASCIISum(char *key, int size)</code>.</li>
                    <li>Cette fonction calcule la <strong>somme des codes ASCII</strong> de tous les caract√®res de la cl√©, modulo la taille de la table.</li>
                    <li>Analysez les nouvelles statistiques via <code>displayStats</code>. La r√©partition est-elle meilleure ?</li>
                </ul>
            </div>
        </section>

        <section id="mission5" class="panel">
            <h2>/// PHASE 5 : FUTUR IMM√âDIAT</h2>
            
            <p>Pour les petits lutins motiv√©s, nous devons pr√©parer le tra√Æneau pour les d√©cennies √† venir.</p>

            <div class="task-list">
                <p>[OBJECTIF 5.1] Hachage de meilleur Qualit√© (DJB2) :</p>
                <ul>
                    <li>La m√©thode "Somme ASCII" est encore trop pr√©visible (les anagrammes comme "RAME" et "MARE" ont le m√™me hash !).</li>
                    <li>Impl√©mentez l'algorithme <strong>DJB2</strong>. Voir la section <strong>ARCHIVES</strong> pour la documentation technique.</li>
                </ul>
            </div>

            <div class="message-box" style="border-color: #ffee00; background: rgba(255, 238, 0, 0.05);">
                <h3>üöÄ D√âFI FINAL : COLONISATION SPATIALE</h3>
                <p><strong>SIMULATION TEMPORELLE : ANN√âE 2050.</strong></p>
                <p>La population humaine s'est √©tendue sur Mars. Nous ne g√©rons plus 2 milliards, mais 20 milliards d'enfants.</p>
                <p>Probl√®me : Notre table de taille fixe sature (Facteur de charge > 10). Les collisions explosent.</p>
            </div>

            <div class="task-list">
                <p>[OBJECTIF 5.2] Redimensionnement Dynamique (Rehashing) :</p>
                <ul>
                    <li>Impl√©mentez une fonction de surveillance <code>float loadFactor(HTable table)</code> (Nombre √©l√©ments / Taille tableau).</li>
                    <li>Si le facteur d√©passe <strong>0.75</strong>, d√©clenchez une proc√©dure d'urgence :
                        <ol>
                            <li>Cr√©er une nouvelle table 2x plus grande.</li>
                            <li>Recalculer le hash de TOUS les enfants existants pour les placer dans la nouvelle table (car <code>modulo size</code> change !).</li>
                            <li>Lib√©rer l'ancienne table.</li>
                        </ol>
                    </li>
                </ul>
            </div>
            
            <div class="code-editor">
                <div class="editor-header">Prototype sugg√©r√©</div>
<pre><code><span class="comment">// Redimensionne la table si n√©cessaire</span>
void verifyAndResize(HTable *table);</code></pre>
            </div>

            <div class="message-box">
                <h3>üöÄ IMPORTATION DE LA LISTE INTERPLAN√âTAIRE</h3>
                <p>Avec la population humaine qui s'√©tend sur d'autres plan√®tes, les donn√©es d'enfants sont maintenant disponibles sur d'autres plan√®tes. Vous pouvez importer la liste des enfants interplan√©taires en utilisant la fonction <code>loadFile</code>.</p>
                <div class="download-zone">
                    <a href="dataset_interplanetary.txt" class="retro-btn">‚¨áÔ∏è DOWNLOAD DATASET_INTERPLANETARY.TXT</a>
                </div>  
            </div>
            
            <p class="subtitle">Bonne chance, petits lutins !</p>
        </section>

        <section id="annex" class="panel">
            <h2>/// CLASSIFIED_DATA_ARCHIVE</h2>
            <p>Acc√®s aux documents historiques du d√©partement R&D.</p>

            <div class="info-terminal">
                > ACCESS GRANTED: Loading historical files...
            </div>

            <h3>DOCUMENT #1 : L'Origine du Hachage</h3>
            <p>L'id√©e du hachage n'est pas nouvelle. Elle a √©t√© formul√©e pour la premi√®re fois au d√©but des ann√©es <strong>1950</strong> par <strong>Hans Peter Luhn</strong> (un ing√©nieur d'IBM).</p>
            <p>Luhn cherchait un moyen d'acc√©l√©rer la recherche de compos√©s chimiques enregistr√©s sous forme cod√©e.</p>

            <hr style="border-color: #333; border-style: dashed;">

            <h3>DOCUMENT #2 : L'Algorithme DJB2</h3>
            <p>L'algorithme que nous utilisons a √©t√© cr√©√© par <strong>Daniel J. Bernstein</strong> (d'o√π le nom "DJB") en 1991.</p>
            
            <p><strong>Pourquoi √ßa marche ?</strong></p>
            <p>Cet algorithme utilise deux "nombres magiques" :</p>
            <ul>
                <li><strong>5381</strong> : La valeur initiale du hash. Ce nombre premier a √©t√© choisi exp√©rimentalement car il produit tr√®s peu de collisions.</li>
                <li><strong>33</strong> : Le multiplicateur. Multiplier par 33 m√©lange tr√®s efficacement les bits du mot binaire.</li>
            </ul>

            <div class="code-editor">
                <div class="editor-header">Impl√©mentation de R√©f√©rence (DJB2)</div>
<pre><code>unsigned long hash(char *str) {
    unsigned long hash = 5381;
    int c;

    while (c = *str++)
        <span class="comment">// L'astuce binaire : (hash << 5) + hash </span>
        <span class="comment">// est une fa√ßon ultra-rapide d'√©crire "hash * 33"</span>
        hash = ((hash << 5) + hash) + c; 

    return hash;
}</code></pre>
            </div>
            <p><em>Note : Le d√©calage de bits <code>&lt;&lt; 5</code> revient √† multiplier par 32. En ajoutant <code>+ hash</code>, on obtient une multiplication par 33, mais beaucoup plus rapide pour le processeur !</em></p>
        </section>
    </main>

    <footer>
        <p>TERMINAL V2.4 | P√îLE NORD IT DEPT | <span id="clock">--:--:--</span></p>
    </footer>
</div>

<div id="retro-tooltip" class="hidden"></div>
<script src="script.js"></script>
</body>

</html>
