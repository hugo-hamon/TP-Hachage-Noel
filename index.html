<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Opération S.L.E.I.D // Terminal</title>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;600&family=VT323&display=swap" rel="stylesheet">
    <link rel="icon" href="icon.png">
</head>
<body>

<div class="scanlines"></div>

<div class="terminal-container">
    <header>
        <div class="top-bar">
            <span>CONN: SECURE (NORTH_POLE_VPN)</span>
            <span>MEM: 64KB OK</span>
        </div>
        <h1>
            <span class="prefix">>>></span> PROJECT <span class="highlight">S.L.E.I.D</span>
        </h1>
        <p class="subtitle">System for Logistics and Efficient Delivery</p>
    </header>

    <nav class="tabs">
        <button class="tab-btn active" data-target="briefing">0. BRIEFING</button>
        <button class="tab-btn" data-target="mission1">1. ARCHITECTURE</button>
        <button class="tab-btn" data-target="mission2">2. MOTEUR</button>
        <button class="tab-btn" data-target="mission3">3. BIG DATA</button>
        <button class="tab-btn" data-target="mission4">4. OPTIMISATION</button>
    </nav>

    <main>
        <section id="briefing" class="panel active">
            <div class="typewriter">
                <p>> Initialisation du canal sécurisé...</p>
                <p>> Décryptage du message du Père Noël...</p>
            </div>
            
            <div class="message-box">
                <h3>⚠️ ALERTE CRITIQUE</h3>
                <p>Cher élève, nous avons un problème. La population mondiale a atteint un seuil critique. Notre base de données actuelle (une simple <span class="tooltip" data-desc="Structure de données où chaque élément pointe vers le suivant. Recherche lente en O(N).">liste chaînée</span>) met trop de temps à vérifier si un enfant a été sage.</p>
                
                <p>Avec <strong>2 milliards d'entrées</strong>, la complexité linéaire nous empêche de distribuer les cadeaux à temps. Nous devons passer à une recherche en <span class="tooltip" data-desc="Temps de recherche indépendant du nombre d'éléments. O(1) signifie que le temps de recherche est constant.">temps constant</span>.</p>
                
                <p><strong>VOTRE MISSION :</strong> Implémenter une <span class="tooltip" data-desc="Tableau associatif permettant de retrouver une clé en temps constant O(1) grâce à une fonction de hachage.">Table de Hachage</span> avant le 24 décembre afin d'aider le Père Noël à distribuer les cadeaux à temps.</p>
            </div>
        </section>

        <section id="mission1" class="panel">
            <h2>/// PHASE 1 : STRUCTURES DE DONNÉES</h2>
            <p>Nous devons définir les conteneurs mémoire. Le système utilise un <span class="tooltip" data-desc="Méthode pour gérer les collisions : si deux clés ont le même hash, on les stocke les unes à la suite des autres dans une liste.">chaînage linéaire</span> pour gérer les conflits d'index.</p>
            
            <div class="task-list">
                <p>[OBJECTIF 1.1] Définir les structures dans <code>santa_hash.h</code> :</p>
            </div>

            <div class="code-editor">
                <div class="editor-header">santa_hash.h</div>
<pre><code>typedef struct {
    char * key;          <span class="comment">/* Login (ex: "Elf_01") */</span>
    char * mail;           <span class="comment">/* Email de contact */</span>
    unsigned int date;   <span class="comment">/* Format AAAAMMJJ ex: 20251215*/</span>
} <span class="tooltip" data-desc="HElement représente un élément de la table de hachage. Ici, les éléments sont composés de 3 champs : une clé correspondant à un login, une adresse mail, et une date d'inscription stockée sous la forme d'unentier non signé">HElement</span>;

typedef struct HCell {
    HElement * element;  <span class="comment">/* Pointeur vers la donnée */</span>
    struct HCell * next; <span class="comment">/* Gestion collision : suivant */</span>
} <span class="tooltip" data-desc="HCell représente une cellule de la table de hachage, c'est-à-dire une enveloppe autour des éléments. Il s'agit des cellules qui composeront les listes simplement chaînées de chaque entrée de la table de hachage.">HCell</span>;

typedef struct {
    HCell ** table;      <span class="comment">/* Tableau de pointeurs (Buckets) */</span>
    unsigned int size;   <span class="comment">/* Taille du tableau */</span>
} <span class="tooltip" data-desc="HTable représente la table de hachage à proprement parler, à l'aide d'un tableau de pointeurs vers une liste simplement chaînée et la taille de ce tableau.">HTable</span>;</code></pre>
            </div>

            <div class="task-list">
                <p>[OBJECTIF 1.2] Implémenter les primitives :</p>
                <ul>
                    <li><code><span class="tooltip" data-desc="Notez que les collisions étant gérées par chaînage linéaire, l’argument size ne correspond pas à la capacité du répertoire mais au nombre d’entrées de la table de hachage. Plus ce nombre est important, moins il y aura de collisions, mais il faudra alors que la fonction de hachage soit adaptée.">HTable* createHTable(unsigned int size)</span></code> :  Permet de  créer un répertoire vide. Cette fontion prend en argument le nombre d’entrées de la table de hachage qui sera retournée. On prendra soin d’initialiser toutes les entrées de cette table à la valeur NULL.</li>
                    <li><code>HElement* createHElement();</code> :  Créer et retourne une nouvelle instance de la structure HElement. Les champs de cette instance seront initialisés par saisie au clavier.</li>
                    <li><code>void printHElement(HElement h_elt);</code> : Affiche sur la sortie standard un élément fourni en argument.</li>
                    <li><code>HCell * enqueueHElement(HCell *h_entry, HElement* h_elt);</code> : Permet d’ajouter un élément à une liste chaînée fournie en argument. Une nouvelle cellule sera créée qui encapsulera l’élément et qui sera ajoutée en queue de liste. Si la liste en argument est égale à NULL alors la fonction retournera une nouvelle liste constituée de l’unique cellule nouvellement créée.</li>
                    <li><code><span class="tooltip" data-desc="Cette fonction fera appel à la fonction printHElement">void printHEntry(HCell *h_entry);</span></code> : Affiche en sortie standard une liste d'éléments fournie en argument.</li>
                </ul>
            </div>
        </section>

        <section id="mission2" class="panel">
            <h2>/// PHASE 2 : INDEXATION & HACHAGE</h2>
            <p>Il faut maintenant distribuer les enfants dans les "tiroirs" (buckets) de la table.</p>

            <div class="info-terminal">
                > INFO: Une <span class="tooltip" data-desc="Situation où deux clés différentes produisent le même index (hash).">collision</span> survient quand deux enfants ont le même hash.
                > ACTION: Ils seront stockés dans la même liste chaînée.
            </div>

            <p><strong>2.1 L'Algorithme Naïf (Prototype)</strong></p>
        </section>

        <section id="mission3" class="panel">
            <h2>/// PHASE 3 : TEST DE CHARGE</h2>
            <p>Le prototype fonctionne. Testons avec la liste globale.</p>
            
            <div class="download-zone">
                <a href="dataset_noel.txt" class="retro-btn">⬇️ TÉLÉCHARGER DATASET_NOEL.TXT</a>
            </div>
        </section>

        <section id="mission4" class="panel">
            <h2>/// PHASE 4 : OPTIMISATION ALGORITHMIQUE</h2>
        </section>
    </main>

    <footer>
        <p>TERMINAL V2.4 | PÔLE NORD IT DEPT | <span id="clock">--:--:--</span></p>
    </footer>
</div>

<div id="retro-tooltip" class="hidden"></div>
<script src="script.js"></script>
</body>

</html>
